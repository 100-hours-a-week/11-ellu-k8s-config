# OpenTelemetry 컬렉터 설정
mode: deployment

# Image configuration
image:
  repository: otel/opentelemetry-collector-k8s
  tag: "0.104.0"
  pullPolicy: IfNotPresent

# 배포 설정
replicaCount: 2

# AWS 노드에 배포
nodeSelector:
  cloud-provider: aws

resources:
  requests:
    memory: 256Mi
    cpu: 100m
  limits:
    memory: 512Mi
    cpu: 500m

# Service configuration
service:
  type: ClusterIP
  
# Ports for receiving telemetry data
ports:
  otlp:
    enabled: true
    containerPort: 4317
    servicePort: 4317
    protocol: TCP
  otlp-http:
    enabled: true
    containerPort: 4318
    servicePort: 4318
    protocol: TCP
  jaeger-grpc:
    enabled: true
    containerPort: 14250
    servicePort: 14250
    protocol: TCP
  jaeger-thrift-http:
    enabled: true
    containerPort: 14268
    servicePort: 14268
    protocol: TCP
  zipkin:
    enabled: true
    containerPort: 9411
    servicePort: 9411
    protocol: TCP
  metrics:
    enabled: true
    containerPort: 8888
    servicePort: 8888
    protocol: TCP

# OpenTelemetry Collector configuration
config:
  receivers:
    # OTLP receiver for your applications
    otlp:
      protocols:
        grpc:
          endpoint: 0.0.0.0:4317
        http:
          endpoint: 0.0.0.0:4318
    
    # Jaeger receiver
    jaeger:
      protocols:
        grpc:
          endpoint: 0.0.0.0:14250
        thrift_http:
          endpoint: 0.0.0.0:14268
    
    # Zipkin receiver
    zipkin:
      endpoint: 0.0.0.0:9411
    
    # Prometheus receiver for scraping metrics
    prometheus:
      config:
        scrape_configs:
          - job_name: 'otel-collector'
            scrape_interval: 15s
            static_configs:
              - targets: ['0.0.0.0:8888']
    
    # Kubernetes objects receiver
    k8s_objects:
      auth_type: serviceAccount
      objects:
        - name: pods
          mode: pull
        - name: services
          mode: pull
        - name: deployments
          mode: pull
        - name: nodes
          mode: pull
    
    # Kubernetes events receiver
    k8s_events:
      auth_type: serviceAccount

  processors:
    # Batch processor for efficiency
    batch:
      timeout: 1s
      send_batch_size: 1024
    
    # Memory limiter to prevent OOM
    memory_limiter:
      limit_mib: 400
    
    # Resource processor to add Kubernetes metadata
    resource:
      attributes:
        - key: service.name
          from_attribute: k8s.deployment.name
          action: upsert
        - key: service.namespace
          from_attribute: k8s.namespace.name
          action: upsert
        - key: k8s.cluster.name
          value: "looper-cluster"
          action: upsert
    
    # Resource detection for Kubernetes
    resourcedetection/k8s:
      detectors: [env, k8snode, k8spod]
      timeout: 2s
      override: false
    
    # Attributes processor for trace enhancement
    attributes:
      actions:
        - key: environment
          value: "kubernetes"
          action: upsert

  exporters:
    # Tempo exporter for traces
    otlp/tempo:
      endpoint: http://tempo:4317
      tls:
        insecure: true
    
    # Prometheus exporter for metrics
    prometheus:
      endpoint: "0.0.0.0:8889"
    
    # OTLP exporter for metrics to Prometheus via remote write
    prometheusremotewrite:
      endpoint: "http://kube-prometheus-stack-prometheus:9090/api/v1/write"
    
    # Debug exporter for troubleshooting
    debug:
      verbosity: basic

  extensions:
    # Health check extension
    health_check:
      endpoint: 0.0.0.0:13133
    
    # pprof extension for profiling
    pprof:
      endpoint: 0.0.0.0:1777
    
    # zpages extension for debugging
    zpages:
      endpoint: 0.0.0.0:55679

  service:
    extensions: [health_check, pprof, zpages]
    pipelines:
      # Traces pipeline
      traces:
        receivers: [otlp, jaeger, zipkin]
        processors: [memory_limiter, resourcedetection/k8s, resource, attributes, batch]
        exporters: [otlp/tempo, debug]
      
      # Metrics pipeline
      metrics:
        receivers: [otlp, prometheus, k8s_objects]
        processors: [memory_limiter, resourcedetection/k8s, resource, batch]
        exporters: [prometheusremotewrite, prometheus, debug]
      
      # Logs pipeline (basic)
      logs:
        receivers: [otlp, k8s_events]
        processors: [memory_limiter, resourcedetection/k8s, resource, batch]
        exporters: [debug]

# RBAC permissions for Kubernetes API access
rbac:
  create: true

# Service account
serviceAccount:
  create: true
  name: ""

# Cluster role for accessing Kubernetes APIs
clusterRole:
  create: true
  rules:
    - apiGroups: [""]
      resources: ["nodes", "nodes/proxy", "services", "endpoints", "pods", "events"]
      verbs: ["get", "list", "watch"]
    - apiGroups: ["apps"]
      resources: ["deployments", "replicasets"]
      verbs: ["get", "list", "watch"]
    - apiGroups: ["networking.k8s.io"]
      resources: ["ingresses"]
      verbs: ["get", "list", "watch"]
    - nonResourceURLs: ["/metrics"]
      verbs: ["get"]

# Pod security context
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 10001
  fsGroup: 10001

# Security context
securityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  capabilities:
    drop:
      - ALL

# ServiceMonitor for Prometheus scraping
serviceMonitor:
  enabled: true
  labels: {}
  interval: 15s
  scrapeTimeout: 10s

# Horizontal Pod Autoscaler
autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 5
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80